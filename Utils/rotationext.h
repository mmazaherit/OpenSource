#pragma  once
#include "ceres/rotation.h"
namespace ceres
{

	// apply a RX+T where R is generated by 3 angle-axis parameters and then point is translated by the last 3 elements of angle_axis_translation
	//angle_axis_translation =[3 angle-axis parameters, 3 translation]
	template<typename T> inline
		static void AngleAxisTransformPoint(const T angle_axis_translation[6], const T pt[3], T result[3])
	{
		ceres::AngleAxisRotatePoint(angle_axis_translation, pt, result);
		result[0] += angle_axis_translation[3];
		result[1] += angle_axis_translation[4];
		result[2] += angle_axis_translation[5];

	}

	template <typename T>
	static inline void EulerAnglesToRzRyRx(const T* euler,
		const int row_stride_parameter,
		T* R) {
		CHECK_EQ(row_stride_parameter, 3);
		EulerAnglesToRzRyRx(euler, RowMajorAdapter3x3(R));
	}
	// ceres default rotation is Rz*Ry*Rx
	template <typename T, int row_stride, int col_stride>
	static void EulerAnglesToRzRyRx(
		const T* euler,
		const MatrixAdapter<T, row_stride, col_stride>& R) {
		const double kPi = 3.14159265358979323846;
		const T degrees_to_radians(kPi / 180.0);

		const T omega(euler[0] * degrees_to_radians);
		const T phi(euler[1] * degrees_to_radians);
		const T kapa(euler[2] * degrees_to_radians);

		const T c1 = cos(kapa);
		const T s1 = sin(kapa);
		const T c2 = cos(phi);
		const T s2 = sin(phi);
		const T c3 = cos(omega);
		const T s3 = sin(omega);

		R(0, 0) = c1*c2;
		R(0, 1) = -s1*c3 + c1*s2*s3;
		R(0, 2) = s1*s3 + c1*s2*c3;

		R(1, 0) = s1*c2;
		R(1, 1) = c1*c3 + s1*s2*s3;
		R(1, 2) = -c1*s3 + s1*s2*c3;

		R(2, 0) = -s2;
		R(2, 1) = c2*s3;
		R(2, 2) = c2*c3;
	}


	// photogrammetric convention M=Mz*My*Mx  where M=R'
	template <typename T>
	static inline void EulerAnglesToMzMyMx(const T* euler,
		const int row_stride_parameter,
		T* MzMyMx) {
		CHECK_EQ(row_stride_parameter, 3);
		EulerAnglesToMzMyMx(euler, RowMajorAdapter3x3(MzMyMx));
	}


	template <typename T, int row_stride, int col_stride>
	static void EulerAnglesToMzMyMx(
		const T* euler,
		const MatrixAdapter<T, row_stride, col_stride>& MzMyMx) {
		const double kPi = 3.14159265358979323846;
		const T degrees_to_radians(kPi / 180.0);

		const T omega(euler[0] * degrees_to_radians);
		const T phi(euler[1] * degrees_to_radians);
		const T kappa(euler[2] * degrees_to_radians);

		const T coskappa = cos(kappa);
		const T sinkappa = sin(kappa);
		const T cosphi = cos(phi);
		const T sinphi = sin(phi);
		const T cosomega = cos(omega);
		const T sinomega = sin(omega);

		MzMyMx(0, 0) = coskappa*cosphi;
		MzMyMx(0, 1) = sinkappa*cosomega + coskappa*sinphi*sinomega;
		MzMyMx(0, 2) = sinkappa*sinomega - coskappa*sinphi*cosomega;

		MzMyMx(1, 0) = -sinkappa*cosphi;
		MzMyMx(1, 1) = coskappa*cosomega - sinkappa*sinphi*sinomega;
		MzMyMx(1, 2) = coskappa*sinomega + sinkappa*sinphi*cosomega;

		MzMyMx(2, 0) = sinphi;
		MzMyMx(2, 1) = -cosphi*sinomega;
		MzMyMx(2, 2) = cosphi*cosomega;
	}

	//two sets of eulr angles corresponds to the same rotation matrix
	template <typename T>
	static inline bool RotationRzRyRxToEuler(const int row_stride_parameter, const T* RzRyRx, T*euler1, T*euler2) {
		CHECK_EQ(row_stride_parameter, 3);
		return RotationRzRyRxToEuler(RowMajorAdapter3x3(RzRyRx), euler1,euler2);
	}

	template <typename T, int row_stride, int col_stride>
	static inline bool RotationRzRyRxToEuler(const MatrixAdapter<T, row_stride, col_stride>& RzRyRx, T* euler1, T* euler2)
	{
		//http://www.staff.city.ac.uk/~sbbh653/publications/euler.pdf
		const double kPi = 3.14159265358979323846;
		const T radians2degreee(180.0 / kPi);		
		
		if (RzRyRx(2, 0) != T(1.0) && RzRyRx(2, 0) != T(-1.0))
		{
			//no ambigiuty

			euler1[1] = -asin(RzRyRx(2, 0))*radians2degreee;
			euler2[1] = T(180.0) - euler1[1];

			T cosPhi1 = cos(euler1[1] / radians2degreee);
			T cosPhi2 = cos(euler2[1] / radians2degreee);

			euler1[0] = atan2(RzRyRx(2, 1) / cosPhi1, RzRyRx(2, 2) / cosPhi1)*radians2degreee;
			euler2[0] = atan2(RzRyRx(2, 1) / cosPhi2, RzRyRx(2, 2) / cosPhi2)*radians2degreee;
										
			euler1[2] = atan2(RzRyRx(1, 0) / cosPhi1, RzRyRx(0, 0) / cosPhi1)*radians2degreee;
			euler2[2] = atan2(RzRyRx(1, 0) / cosPhi2, RzRyRx(0, 0) / cosPhi2)*radians2degreee;
			return true;
		}
		else 
			if (RzRyRx(2, 0) == T(-1.0))
			{
			euler1[2]= euler2[2] = T(0.0);// can be anything
			euler1[1]= euler2[1] = T(90.0);
			euler1[0]= euler2[0] = euler1[2] +atan2(RzRyRx(0,1),  RzRyRx(0,2))*radians2degreee;
			return false;
			}
		else
			if(RzRyRx(2, 0) == T(1.0))
		{
			euler1[2] = euler2[2] = T(0.0);// can be anything
			euler1[1] = euler2[1] = T(-90.0);
			euler1[0] = euler2[0] = -euler1[2] + atan2(-RzRyRx(0, 1), -RzRyRx(0, 2))*radians2degreee;
			return false;
		}

		return false;
	}



	template <typename T>
	static inline void RotationRzRxRyToRPY(const int row_stride_parameter, const T* RzRxRy, T*euler) {
		CHECK_EQ(row_stride_parameter, 3);
		RotationRzRxRyToRPY(RowMajorAdapter3x3(RzRxRy), euler);
	}
	template <typename T, int row_stride, int col_stride>
	static inline void	RotationRzRxRyToRPY(const MatrixAdapter<T, row_stride, col_stride>& RzRxRy, T* RPY)
	{
		const double kPi = 3.14159265358979323846;
		const T radians2degreee(180.0 / kPi);

		RPY[0] = atan2(-RzRxRy(2, 0),  RzRxRy(2, 2))*radians2degreee;
		RPY[1] = asin( RzRxRy(2, 1))*radians2degreee;
		RPY[2] = atan2(-RzRxRy(0, 1), RzRxRy(1, 1))*radians2degreee;
	}
	template <typename T>
	static inline void RPYToRzRxRy(const T* RPY,
		const int row_stride_parameter,
		T* R) {
		CHECK_EQ(row_stride_parameter, 3);
		RPYToRzRxRy(RPY, RowMajorAdapter3x3(R));
	}

	template <typename T, int row_stride, int col_stride>
	static void RPYToRzRxRy(const T* RPY,const MatrixAdapter<T, row_stride, col_stride>& RzRxRy) 
	{
		const double kPi = 3.14159265358979323846;
		const T degrees_to_radians(kPi / 180.0);

		const T Roll(RPY[0] * degrees_to_radians);
		const T Pitch(RPY[1] * degrees_to_radians);
		const T Yaw(RPY[2] * degrees_to_radians);

		const T cosyaw = cos(Yaw);
		const T sinyaw = sin(Yaw);
		const T cospitch = cos(Pitch);
		const T sinpitch = sin(Pitch);
		const T cosroll = cos(Roll);
		const T sinroll = sin(Roll);

		RzRxRy(0, 0) = cosroll*cosyaw - sinpitch*sinroll*sinyaw;
		RzRxRy(0, 1) = -cospitch*sinyaw;
		RzRxRy(0, 2) = cosyaw*sinroll + cosroll*sinpitch*sinyaw;

		RzRxRy(1, 0) = cosroll*sinyaw + cosyaw*sinpitch*sinroll;
		RzRxRy(1, 1) = cospitch*cosyaw;
		RzRxRy(1, 2) = sinroll*sinyaw - cosroll*cosyaw*sinpitch;

		RzRxRy(2, 0) = -cospitch*sinroll;
		RzRxRy(2, 1) = sinpitch;
		RzRxRy(2, 2) = cospitch*cosroll;
	}
	template <typename T>
	static inline void TransposeRotation(const T* const R, T* Rt)
	{
		Rt[0] = R[0];
		Rt[1] = R[3];
		Rt[2] = R[6];

		Rt[3] = R[1];
		Rt[4] = R[4];
		Rt[5] = R[7];

		Rt[6] = R[2];
		Rt[7] = R[5];
		Rt[8] = R[8];

	}

	template <typename T>
	static inline void RotatePoint(const T* const R, const T* const Pt, T* RotatedPoint)
	{
		RotatedPoint[0] = R[0] * Pt[0] + R[1] * Pt[1] + R[2] * Pt[2];
		RotatedPoint[1] = R[3] * Pt[0] + R[4] * Pt[1] + R[5] * Pt[2];
		RotatedPoint[2] = R[6] * Pt[0] + R[7] * Pt[1] + R[8] * Pt[2];
	}

//https://www.mathworks.com/help/aeroblks/quaternionmultiplication.html
	template <typename T>
	static inline void RotationQuaternionProduct(const T* const q, const T* const r, T* qr)
	{
		qr[0] = r[0] * q[0] - r[1] * q[1] - r[2] * q[2] - r[3] * q[3];
		qr[1] = r[0] * q[1] + r[1] * q[0] - r[2] * q[3] + r[3] * q[2];
		qr[2] = r[0] * q[2] + r[1] * q[3] + r[2] * q[0] - r[3] * q[1];
		qr[3] = r[0] * q[3] - r[1] * q[2] + r[2] * q[1] + r[3] * q[0];

		T nrmqr = Norm41(qr);
		Scale41(T(1.0) / nrmqr, qr);
	}

	
	
}

void TestEulerAnglesToRzRyRx()
{
	double eulerinput1[3]{ 10,20,30 };
	double Rinput1[9];
	ceres::EulerAnglesToRotationMatrix(eulerinput1, ceres::RowMajorAdapter3x3(Rinput1));

	double eulers1[3], eulers2[3], testR1[9], testR2[9];

	ceres::RotationRzRyRxToEuler(ceres::RowMajorAdapter3x3(Rinput1), eulers1, eulers2);
	ceres::EulerAnglesToRzRyRx(eulers1, ceres::RowMajorAdapter3x3(testR1));
	ceres::EulerAnglesToRzRyRx(eulers2, ceres::RowMajorAdapter3x3(testR2));

	Subtractn<double, 9>(testR1, testR1, testR2);

	double eulerinputambig[3]{ -10,90,0 };
	double Rinputamb[9];
	ceres::EulerAnglesToRzRyRx(eulerinputambig, ceres::RowMajorAdapter3x3(Rinputamb));
	ceres::RotationRzRyRxToEuler(ceres::RowMajorAdapter3x3(Rinputamb), eulers1, eulers2);

	ceres::EulerAnglesToRzRyRx(eulers1, ceres::RowMajorAdapter3x3(testR1));
}